Java多线程和内存模型（二）
===
### java创建线程的方法：
+ 继承 Thread 类
+ 通过 Runnable 接口创建线程类
	 + 定义 runnable 接口实现类，并重写接口的 run（） 方法，作为线程的执行体；
	 + 创建 Runnable  实现类的实例，并作为线程的目标来创建Thread对象；
	 +  最后调用 start（） 方法启动线程
+ 通过  Callable 和 Future 创建线程
	+ 创建 Callable 接口实现类，并实现 call() 方法，其作为线程的执行体，存在返回值；
	+ 创建 Callable 实现类的实例， 使用FutureTask 类包装 Callable 对象 ，其封装了 Callable 对象的 call( ) 方法的返回值；
	+ 使用FutureTask对象作为Thread 对象的 target 创建并启动新线程；
	+ 可以调用 FutureTask 对象的 get（） 方法来获取子线程执行结果的返回值，并且会产生阻塞效果；

### 三种创建的方式的对比：
1， 通过实现接口的创建方式
优势：
+ 线程类只是实现了 Runnable 和 Callable 接口，还可以继承其他类。使得功能更丰富；
 + 多个线程可以共享同一个Target 对象，适合多个相同线程处理同一份资源的情况；
 
 劣势：
 + 编程稍微复杂，每次访问当前线程的时候，必须使用Thread.currentThread() 方法；

2，继承Thread类的优势：
优势：
+  访问简单，直接this；
+  表达简洁明了；

劣势：
+ 不可再拓展继承别的类，功能单一；

### 线程池
> 当程序中需要创建大量生存期很短的线程的时候，可以使用线程池；
> 线程池的作用： 线程池在启动的时候创建大量的空闲线程；用来统一管理创建出来的子线程；避免他们互相竞争而导致占用过多的资源而导致死机或 OOM；

线程池包括四个基本组成部分；
+ 线程池管理器（ThreadPool）： 用于创建并管理线程池，包括创建线程池，销毁线程池，添加新任务；
+ 工作线程（PoolWorker）： 线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
+ 任务接口（Task）： 每个任务必须实现的接口，以供工作线程调度执行，它主要规定了任务的入口，任务执行完成后的收尾工作，任务执行状态等；
+ 任务队列（taskQueue）:  用于存放没有处理的任务，提供缓存作用；

##### 使用线程的池举例：
假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。

   如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。

优势：
1，降低系统资源的消耗，通过重用已存在的线程，降低线程的创建和销毁造成的消耗；
2，提高反应速度，新任务到来的时候无需重新创建；
3，方便控制线程的并发数，减少OOM，提高资源使用率；
4，提供了定时，定期以及可控线程数等功能的线程池；

#### 线程池的创建：
`ExecutorService	service	=	new	ThreadPoolExecutor(5,	10,	10,	Time Unit.SECONDS,	new	LinkedBlockingQueue<>());`

线程池的基本操作：
添加：
+ execute ：没有返回值，无法判定线程池是否操作成功；
+ submit：会返回一个future ，根据判断任务是否执行成功，还可以通过 get() 方法获取返回值。如果子线程任务没有完成，get方法会阻塞到任务完成；

关闭线程池：
+ shutdown() : 将线程池状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程；
+  shutdownNow() ： 将线程池状态设置成STOP状态，然后中断所有任务（包括正在执行的）线程，并且返回正在等待的列表；

中断采用的 Interrupt 方法，所以在一些无法响应中断的任务可能永远无法终止；

#### 线程池的执行流程 
+ 提交任务
+ 判断线程池是否满？
	+ 是 ： 创建新的线程执行任务
	+ 否：插入到任务队列中排队等待执行；
+ 判断工作队列是否已满？
	+ 否：添加到队列等待执行；
	+ 是：判断线程池是否已满？
		+ 否： 创建新的非核心线程去执行任务；
		+ 是：按照饱和策略处理无法执行的任务； 

#### 常见的线程池：
1，newFixedThreadPool ： 线程数量固定的线程池；
特点：最大线程数 == 核心的线程数，并且没有超时机制，导致即使核心线程在闲置状态也不会被回收；任务队列 LinkedBlockingQueue 没有界限；
	缺点： 容易造成内存占用过多问题；
应用： 需要快速响应外界请求；

2，newCachedThreadPool 
核心线程数为0；保活的时间为 1min ；
任务队列为：SynchronousQueue；
遇到新任务会直接分配或创建一个线程进行执行；
适用于：希望的提交的任务需要马上执行的

3， SingleThreadExecutor 
核心线程：1
最大线程数：1
对任务队列没有限制；
只能使用一个线程进行任务处理，无需处理线程同步的问题；


#### 线程池的使用：
按照任务类别去划分：
+ CPU密集型任务
	+ 线程池的中的线程经可能的少，比当前CPU的个数多一就好；（要是任务多了，花在任务切换的时间就越多，CPU执行任务的效率就越低）
+ IO密集型任务
	+ 由于IO的速度很慢，在运行的时候，很多CPU会处于空闲状态，所以可以让核心线程数稍微多一点，常为CPU数的两倍；
+ 混合型任务
